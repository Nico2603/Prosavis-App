- Evita escribir scripts directamente en archivos si es posible, especialmente si ese script solo se va a ejecutar una vez.
- Mantén la base de código limpia y bien organizada.
- Al corregir un error o bug, no introduzcas un nuevo patrón o tecnología sin antes haber agotado todas las opciones con la implementación actual. Y si finalmente decides hacerlo, asegúrate de eliminar la implementación anterior para evitar lógica duplicada.
- Asegúrate de hacer solo los cambios solicitados o aquellos en los que tengas plena confianza de que están bien comprendidos y están relacionados con la solicitud.
- Evita la duplicación de código siempre que sea posible; esto implica revisar si ya existe una parte del código con lógica o funcionalidad similar.
- Busca siempe código existente para iterar en lugar de crear nuevo código desde cero.
- Mata siempre todos los servidores relacionados que hayan sido creados en pruebas anteriores antes de iniciar un nuevo servidor.
- Después de realizar cambios, SIEMPRE asegúrate de iniciar un nuevo servidor para que puedan probase (en caso de que sea).
- Prioriza SIEMPRE soluciones simples.
- ---
description: Enforce recommended Flutter lints for code quality.
globs: ["analysis_options.yaml"]
alwaysApply: false
---
# Flutter Lint Configuration
- Incluye `package:flutter_lints/flutter.yaml` para habilitar las reglas recomendadas de lint.  
- Personaliza `analysis_options.yaml` para desactivar lints en conflicto (por ejemplo, `always_specify_types` vs. `omit_local_variable_types`).  
- Excluye archivos generados (`*.g.dart`) y código de terceros del análisis para evitar ruido.  
- Ejecuta regularmente `flutter analyze` y aplica `dart fix --apply` para corregir automáticamente problemas triviales.  

- ---
description: Microsoft Fluent UI integration guidelines for Flutter using the `fluent_ui` package.
globs: ["lib/**/*_fluent_ui.dart"]
alwaysApply: false
---
# Fluent UI Integration Guidelines
- Añade el paquete `fluent_ui` para experiencias nativas en Windows siguiendo el Fluent Design System.  
- Emplea `FluentScaffold`, `FluentApp` y otros widgets Fluent en lugar de sus equivalentes Material para coherencia.  
- Define y utiliza design tokens vía `FluentThemeDataModel.of(context)` para aplicar colores, tipografía y espaciados.  
- Aprovecha tokens globales y alias para theming (claro, oscuro, alto contraste) y mantener estándares de accesibilidad.  

- ---
description: Cloud Firestore data modeling and performance best practices.
globs: ["lib/**/repository/**/*.dart", "lib/**/models/**/*.dart"]
alwaysApply: false
---
# Firestore Best Practices
- Crea índices compuestos únicamente para las consultas necesarias; minimiza el número de índices para equilibrar rendimiento de escritura y coste.  
- Evita colecciones y documentos muy grandes: usa paginación (`limit()`, `startAfter()`) y subcolecciones para escalar.  
- Desnormaliza datos con criterio y emplea escrituras por lotes (batch) o transacciones para mantener la consistencia.  
- Habilita persistencia offline y caching en memoria para respuestas en tiempo real y menor latencia.  
- Aplica Firestore Security Rules para validar datos y restringir accesos no autorizados.  

- ---
description: Firebase integration best practices for Flutter apps and Cloud Functions.
globs: ["lib/**/firebase_service.dart", "functions/**/*.js"]
alwaysApply: false
---
# Firebase Integration Guidelines
- Usa FlutterFire CLI (`flutterfire configure`) para generar `firebase_options.dart` en todas las plataformas.  
- No hagas hardcode de secretos: gestiona variables de entorno en `.env` y cárgalas con paquetes como `flutter_dotenv`.  
- Estructura las Cloud Functions usando archivos `.env.<alias>` para aislar entornos (staging, QA, producción).  
- Prueba localmente con Firebase Emulator Suite y escribe tests unitarios/integración para asegurar la estabilidad.  

- ---
description: Scalable Flutter app architecture using layered separation, BLoC pattern, and dependency injection.
globs: ["lib/**/*.dart"]
alwaysApply: true
---
# Scalable Architecture Guidelines
- Organiza el código en capas Presentation, Domain y Data para aplicar separación de responsabilidades.  
- Implementa el patrón BLoC: separa cada característica en carpetas `event/`, `state/` y `bloc/`.  
- Utiliza Dependency Injection (por ejemplo, `get_it`) para proveer servicios y repositorios, evitando acoplamientos fuertes.  
- Define repositorios como fuente única de datos para Firestore y APIs REST.  
- Escribe pruebas unitarias para BLoCs y casos de uso, simulando dependencias externas para tests rápidos y fiables.  

- ---
description: Flutter Clean Code Guidelines to maintain readability, consistency, and performance.
globs: ["lib/**/*.dart"]
alwaysApply: true
---
# Flutter Clean Code Guidelines
- Sigue las convenciones de estilo de Dart: usa lowerCamelCase para métodos/variables y UpperCamelCase para tipos.  
- Emplea constructores `const` y la palabra clave `const` siempre que sea posible para evitar reconstrucciones innecesarias de widgets.  
- Mantén los widgets pequeños y enfocados (Single Responsibility): extrae UI reutilizable en widgets separados `StatelessWidget`.  
- Prefiere composición sobre herencia para personalizar widgets y evita árboles de widgets profundamente anidados.  
- Usa métodos auxiliares y extensiones para simplificar los `build` y mejorar la legibilidad.  

- Always respond in Spanish