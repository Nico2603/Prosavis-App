import 'dart:io';
import 'dart:developer' as developer;
import 'package:firebase_storage/firebase_storage.dart';
import 'package:path/path.dart' as path;
import '../../core/constants/app_constants.dart';

class ImageStorageService {
  static FirebaseStorage? _storage;

  FirebaseStorage get storage {
    _storage ??= FirebaseStorage.instance;
    return _storage!;
  }

  /// Sube una imagen de perfil y retorna la URL de descarga
  Future<String?> uploadProfileImage(String userId, File imageFile) async {
    try {
      final firebaseStorage = storage;

      // Generar nombre √∫nico para la imagen
      final String fileName = '${userId}_${DateTime.now().millisecondsSinceEpoch}${path.extension(imageFile.path)}';
      
      // Referencia al archivo en Firebase Storage
      final Reference ref = firebaseStorage
          .ref()
          .child(AppConstants.profileImagesPath)
          .child(fileName);

      // Subir archivo
      developer.log('üì§ Subiendo imagen de perfil...');
      final UploadTask uploadTask = ref.putFile(imageFile);
      
      // Esperar a que se complete la subida
      final TaskSnapshot snapshot = await uploadTask;
      
      // Obtener URL de descarga
      final String downloadUrl = await snapshot.ref.getDownloadURL();
      
      developer.log('‚úÖ Imagen de perfil subida exitosamente: $downloadUrl');
      return downloadUrl;
      
    } catch (e) {
      developer.log('‚ùå Error al subir imagen de perfil: $e');
      return null;
    }
  }

  /// Elimina una imagen de perfil usando su URL
  Future<bool> deleteProfileImage(String imageUrl) async {
    try {
      final firebaseStorage = storage;

      // Obtener referencia desde la URL
      final Reference ref = firebaseStorage.refFromURL(imageUrl);
      
      // Eliminar imagen
      await ref.delete();
      
      developer.log('‚úÖ Imagen de perfil eliminada exitosamente');
      return true;
      
    } catch (e) {
      developer.log('‚ùå Error al eliminar imagen de perfil: $e');
      return false;
    }
  }

  /// Actualiza la imagen de perfil (elimina la anterior si existe y sube la nueva)
  Future<String?> updateProfileImage(String userId, File newImageFile, String? currentImageUrl) async {
    try {
      // Si hay una imagen actual, eliminarla primero
      if (currentImageUrl != null && currentImageUrl.isNotEmpty) {
        await deleteProfileImage(currentImageUrl);
      }
      
      // Subir nueva imagen
      return await uploadProfileImage(userId, newImageFile);
      
    } catch (e) {
      developer.log('‚ùå Error al actualizar imagen de perfil: $e');
      return null;
    }
  }

  /// Sube una imagen de servicio y retorna la URL de descarga
  Future<String?> uploadServiceImage(String serviceId, File imageFile) async {
    try {
      final firebaseStorage = storage;

      // Validar que el archivo existe
      if (!imageFile.existsSync()) {
        developer.log('‚ùå Error: El archivo de imagen no existe');
        return null;
      }

      // Validar tama√±o del archivo (m√°ximo 10MB como en las reglas)
      final fileSize = imageFile.lengthSync();
      if (fileSize > 10 * 1024 * 1024) {
        developer.log('‚ùå Error: Imagen demasiado grande (m√°ximo 10MB)');
        return null;
      }

      // Generar nombre √∫nico para la imagen
      final String fileName = '${serviceId}_${DateTime.now().millisecondsSinceEpoch}${path.extension(imageFile.path)}';
      
      // Referencia al archivo en Firebase Storage
      final Reference ref = firebaseStorage
          .ref()
          .child(AppConstants.serviceImagesPath)
          .child(fileName);

      // Configurar metadatos para mejor manejo
      final metadata = SettableMetadata(
        contentType: _getContentType(path.extension(imageFile.path)),
        customMetadata: {
          'serviceId': serviceId,
          'uploadedAt': DateTime.now().toIso8601String(),
        },
      );

      // Subir archivo con reintentos
      developer.log('üì§ Subiendo imagen de servicio: $fileName');
      
      String? downloadUrl;
      int attempts = 0;
      const maxAttempts = 3;
      
      while (attempts < maxAttempts && downloadUrl == null) {
        try {
          attempts++;
          developer.log('üì§ Intento $attempts/$maxAttempts...');
          
          final UploadTask uploadTask = ref.putFile(imageFile, metadata);
          
          // Esperar a que se complete la subida
          final TaskSnapshot snapshot = await uploadTask;
          
          // Verificar que la subida fue exitosa
          if (snapshot.state == TaskState.success) {
            // Obtener URL de descarga
            downloadUrl = await snapshot.ref.getDownloadURL();
            developer.log('‚úÖ Imagen de servicio subida exitosamente: $downloadUrl');
          } else {
            developer.log('‚ùå Error en el estado de la subida: ${snapshot.state}');
          }
          
        } catch (e) {
          developer.log('‚ùå Error en intento $attempts: $e');
          if (attempts < maxAttempts) {
            // Esperar antes del siguiente intento
            await Future.delayed(Duration(seconds: attempts * 2));
          }
        }
      }
      
      return downloadUrl;
      
    } catch (e) {
      developer.log('‚ùå Error general al subir imagen de servicio: $e');
      return null;
    }
  }

  /// Determina el content type basado en la extensi√≥n del archivo
  String _getContentType(String extension) {
    switch (extension.toLowerCase()) {
      case '.jpg':
      case '.jpeg':
        return 'image/jpeg';
      case '.png':
        return 'image/png';
      case '.webp':
        return 'image/webp';
      default:
        return 'image/jpeg'; // Por defecto
    }
  }

  /// Elimina una imagen de servicio usando su URL
  Future<bool> deleteServiceImage(String imageUrl) async {
    try {
      final firebaseStorage = storage;

      // Obtener referencia desde la URL
      final Reference ref = firebaseStorage.refFromURL(imageUrl);
      
      // Eliminar imagen
      await ref.delete();
      
      developer.log('‚úÖ Imagen de servicio eliminada exitosamente');
      return true;
      
    } catch (e) {
      developer.log('‚ùå Error al eliminar imagen de servicio: $e');
      return false;
    }
  }

  /// Sube m√∫ltiples im√°genes de servicio y retorna las URLs
  Future<List<String>> uploadMultipleServiceImages(String serviceId, List<File> imageFiles) async {
    try {
      final List<String> uploadedUrls = [];
      
      if (imageFiles.isEmpty) {
        developer.log('‚ö†Ô∏è Lista de im√°genes vac√≠a');
        return uploadedUrls;
      }
      
      developer.log('üì§ Subiendo ${imageFiles.length} im√°genes de servicio...');
      
      // Subir im√°genes en paralelo para mejor rendimiento
      final futures = imageFiles.map((imageFile) => uploadServiceImage(serviceId, imageFile));
      final results = await Future.wait(futures);
      
      // Filtrar resultados exitosos
      for (final url in results) {
        if (url != null) {
          uploadedUrls.add(url);
        }
      }
      
      developer.log('‚úÖ ${uploadedUrls.length}/${imageFiles.length} im√°genes de servicio subidas exitosamente');
      
      if (uploadedUrls.length < imageFiles.length) {
        final failed = imageFiles.length - uploadedUrls.length;
        developer.log('‚ö†Ô∏è $failed im√°genes fallaron al subir');
      }
      
      return uploadedUrls;
      
    } catch (e) {
      developer.log('‚ùå Error al subir m√∫ltiples im√°genes de servicio: $e');
      return [];
    }
  }

  /// Elimina m√∫ltiples im√°genes de servicio
  Future<bool> deleteMultipleServiceImages(List<String> imageUrls) async {
    try {
      int deletedCount = 0;
      
      for (final imageUrl in imageUrls) {
        final success = await deleteServiceImage(imageUrl);
        if (success) deletedCount++;
      }
      
      developer.log('‚úÖ $deletedCount/${imageUrls.length} im√°genes de servicio eliminadas');
      return deletedCount == imageUrls.length;
      
    } catch (e) {
      developer.log('‚ùå Error al eliminar m√∫ltiples im√°genes de servicio: $e');
      return false;
    }
  }
}